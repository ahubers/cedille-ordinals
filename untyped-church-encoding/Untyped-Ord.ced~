import core.top.

module Untyped-Ord.

-- In this file we'll implement ordinals in untyped lambda
-- calculus following Church and Kleene in "Formal
-- Definitions of Ordinal Numbers", 1930 something.
--------------------------------------------------------------------------------

-- In Cedille, we can "type" any untyped term by giving it
-- type "Top" and encapsulating its body with β{| ... |}.
-- Here we first define id and the naturals as they are
-- expected.
id    : Top = β{| λ x. x |}.
zero  : Top = β{| λ f. λ x. x |}.
succ  : Top = β{| λ n. λ f. λ x. f ((n f) x) |}.

one   : Top = β{| λ f. λ x. f x |}.
two   : Top = β{| λ f. λ x. succ one |}.
three : Top = β{| λ f. λ x. succ two |}.
four  : Top = β{| λ f. λ x. succ three |}.

zero_o : Top = β{| λ m. m one |}.
succ_o : Top = β{| λ a. λ m. (m two) a |}.
limit  : Top = β{| λ a. λ r. λ m. ((m three) a) r |}.

-- We can assert that two terms are beta-eta equal by using
-- the following syntax: { t1 ≃ t2 } = β.  Note that here
-- Cedille reasons that one and succ zero are beta-eta
-- equivalent, even thought we defined one without `succ`.
trivial : { one ≃ succ zero } = β.


-- Per the paper, we can define ω as follows:
omega : Top = β{| (limit zero_o) id |}.

-- From here Church and Kleene give a method which to construct
-- addition, multiplication, and exponentiation.
-- it's still TODO:
--------------------------------------------------------------------------------

-- If we have f such that:
-- f zero_o = id
-- f succ a = λ x. succ (f(a, x))
-- f (limit a r) = λ x. limit(a, λ m. f(r(m), x))
--
-- then f(a, b) = a + b

-- TO build such a function, we need the following:

-- helper1 : Top = β{| λ f. λ b. (b four) f|}.
-- helper2 : Top = β{| λ f. λ b. f (λ x. x (λ n. (b n) b)) |}.

-- -- Then we construct eight formulas such that, for terms A,
-- -- G, and H with no free variables, and indices i, j, k each
-- -- either 1, or 2:
-- --
-- -- B_ijk(1) = helper_i(A)
-- -- B_ijk(2) = helper_j(G)
-- -- B_ijk(3) = helper_k(H)
-- -- B_ijk(4) = id
-- -- then
-- -- f_ijk = λ x. x (λ n. (B_ijk n) B_ijk)
-- --

-- -- For implementation, we're going to encode i, j, k as booleans such that
-- -- 1 is mapped to zero and 2 is mapped to true.

-- true  : Top = β{| λ x. λ y. x |}.
-- false : Top = β{| λ x. λ y. y |}.


-- -- B : Top = β{| λ i. λ j. λ k. λ n.
-- --   (i (helper1 A) (helper2 G)
-- --   )

-- cond : Top = β{| λ b. λ n. (b (helper1 n) (helper2 n))  |}.

-- -- if i is true then return helper1, if j is true 
-- B : Top
--   = β{| λ i. λ j. λ k. λ n.
--     	(i (cond i)
-- 	   (j (cond j)
-- 	      (k (cond k)))) n
-- |}.

-- f : Top = β{| λ i. λ j. λ k. λ x. x (λ n. (B i j k n) (B i j k) ) |}.

-- Bi1 : Top = β{| λ n. ● |}.
-- _  : { Bi1 one ≃ helper1 A } = β.

-- Bi2 : Top = β{| λ n. ● |}.
-- _  : { Bi2 one ≃ helper2 A } = β.

-- Bj1 : Top = β{| λ n. ● |}.
-- _  : { Bj1 two ≃ helper1 G } = β.

-- Bj2 : Top = β{| λ n. ● |}.
-- _  : { Bj2 two ≃ helper2 G } = β.

-- Bk1 : Top = β{| λ n. ● |}.
-- _   : { Bk1 three ≃ helper1 G } = β.

-- Bk2 : Top = β{| λ n. ● |}.
-- _   : { Bk2 two ≃ helper2 G } = β.

-- Bid : Top = β{| λ n. ● |}.
-- _   : {Bid four ≃ id } = β.
